---
title: 컴퓨터는 부동소수를 어떻게 표현할까?
subTitle: 
category:
cover:
---


Python을 이용해 숫자를 계산하다 보면 가끔 상식적이지 않은 상황을 겪을 때가 있습니다.

```
>>> 1 - 0.9 == 0.1
False
>>> 1 - 0.2 == 0.2 
False
>>> 1 - 0.5 == 0.5
True
>>>
```

상식적으로  `1 - 0.9`를 `0.1`과 비교했을때 결과는 `True`를 예상합니다. 하지만 python에서는 `False`를 리턴합니다. 그러나 `1 - 0.5`를 `0.5`와 비교했을때는 `True`를 리턴합니다. 

이러한 결과가 발생하는 이유는 컴퓨터는 기본적으로 모든 숫자를 2진수로 바꾸어 계산하기 때문입니다. 그렇기 때문에 Python 언어 뿐만 아닌 **IEEE-754 부동 소수점 산술**을 사용하는 모든 기계에서 위와 같은 동일한 결과를 반환합니다.

여기서 **[부동 소수점]([https://ko.wikipedia.org/wiki/%EB%B6%80%EB%8F%99%EC%86%8C%EC%88%98%EC%A0%90](https://ko.wikipedia.org/wiki/부동소수점))**이란 위키피디아의 설명에 따르면 다음과 같습니다.

> 실수(float)를 컴퓨터상에서 근사하여 표현할 때 소수점의 위치를 고정하지 않고 그 위치를 나타내는 수를 따로 적는 것으로, 유효숫자를 나타내는 가수와 소수점의 위치를 풀이하는 지수로 나누어 표현한다.

쉽게말해 **10진수로 표기된 소수**를 **2진수로 변환할 때** 정확히 나누어 떨어지지 않는 경우 **근사값으로 표현하는 방식**을 말합니다.



예를들어, 소수

```python
0.125
```

는 1/10 + 2/100 + 5/1000의 값을 가지며, 같은 방식으로 이진 소수

```python
0.001
```

는 값 0/2 + 0/4 + 1/8을 가집니다. 이 두 소수는 같은 값을 가지며, 유일한 차이점은 첫 번째 소수는 10진수의 분수 표기법으로  작성 되었고 두번째 소수는 2진수의 분수 표기법으로 작성 되었다는 점 입니다.

불행히도, 대부분의 10진 소수를 정확하게 2진 소수로 표현될 수 없습니다. 그렇기 때문에 10진 부동 소수점 수가 실제로 기계에 저장될 때는 2진 부동 소수점 수로 근사 될 뿐입니다.

예를들어 분수 1/3을 10진 소수로 바꾸면 다음과 같습니다.

```python
0.3
```

이 수를 좀 더 정확하게 하면

```python
0.33
```

더 정확하게

```python
0.333
```

이렇게 아무리 많은 자릿수로 표현해도 1/3과 정확히 일치하는 값을 2진수로 표현할 수 없습니다.

같은 방식으로 맨 처음의 예 에서 10진수 0.1은 2진 소수로 표현하면 다음과 같습니다.

```python
0.0001100110011001100110011001100110011001100110011...
```

이 숫자를 다시 사용자가 이해하는 10진 근사값으로 출력하게 되면

```
>>> 0.1
0.1000000000000000055511151231257827021181583404541015625
```

과 같이 표현됩니다.



그렇다면 우리가 예상한 결과를 얻기 위해서는 어떻게 해야 할까요?

예를 들어, 0.1은 정확히 1/10이 아니므로, 0.1의 세개를 합한 것 역시 정확히 0.3이 아닙니다.

```
>>> .1 + .1 + .1 == .3
False
```

또한, 0.1은 1/10의 정확한 값에 더 가까워질 수 없고, 0.3도 3/10의 정확한 겂에 더 가까워질 수 없으므로 `round()` 함수로 미리 반올림하는 것은 도움이 되지 않습니다.

```
>>> round(.1, 1) + round(.1, 1) + round(.1, 1) == round(.3, 1)
False
```

숫자를 의도한 정확한 겂에 더 가깝게 만들 수 없지만, `round()` 함수는 사후 반올림에서 유용하여 부정확한 값을 가진 결과를 서로 비교할 수 있게 됩니다.



일반적으로 단순히 계산된 최종 소수를 표시하기 위해서는 보통 `str()` 만으로도 충분하며, 더 세밀하게 제어하려면 **[Format String Syntax](https://docs.python.org/ko/3.6/library/string.html#formatstrings)**에서 `str.format()` 메서드의 포맷 지정자를 확인해 보면 됩니다.

더 정확한 산술을 구현하기 위해서는 `decimal`, `fractions` 모듈 등 다양한 모듈들이 있지만 Python은 `float`의 간단한 메소드 만으로도 더 정확한 값을 계산할 수 있습니다.

```
>>> x = 3.14159
>>> x.as_integer_ratio()
(3537115888337719, 1125899906842624)
```

`float.as_integer_ratio()` 메서드는 float의 값을 분수로 표현합니다. 비율은 정확한 값이기 때문에, 원래 값을 손실 없이 다시 만드는 데 사용할 수 있습니다.

```
>>> x == 3537115888337719 / 1125899906842624
True
```



또한 `float.hex()` 메서드는 float를 16진수로 표현하는데, 컴퓨터에 저장된 정확한 겂을 줍니다.

```
>>> x.hex()
'0x1.921f9f01b866ep+1'
```

이 정확한 16진수 표현은 float 값을 정확하게 재구성하는 데 사용할 수 있습니다.

```
>>> x == float.fromhex('0x1.921f9f01b866ep+1')
True
```


